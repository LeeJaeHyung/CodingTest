/*
문제
베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.

이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.

예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)

자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. 

입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.

입력의 마지막에는 0이 주어진다.

출력
각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.
*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
	
	static boolean[] idx;
	static double loopSize;
	static StringBuilder outSb = new StringBuilder();
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		int size = 0;
		while(true) {//입력을 받는 단계
			String check = br.readLine();
			if(check.equals("0")) {
				break;
			}
			sb.append(check+" ");
		}
		StringTokenizer st = new StringTokenizer(sb.toString());
		int[] input = new int[st.countTokens()];
		for(int i = 0; i<input.length; i++) {
			input[i] = Integer.parseInt(st.nextToken());
			if(size<input[i]) {
				size = input[i];
			}
		} 
		idx = new boolean[size*2+1];
		eratos();
		for(int loop : input) {
			process(loop);
		}
		System.out.println(outSb);
		
	}
	public static void eratos() {
		loopSize = Math.sqrt(idx.length);
		idx[1] = true;//1은 소수가 아님으로 초기화
		for(int i = 2; i<=loopSize; i++) {
			if(!idx[i]) {
				for(int j = i+i; j<idx.length; j+=i) {
					idx[j] = true;
				}
			}
		}
	}
	public static void process(int n) {
		int n2 = n+n;
		int count = 0;
		for(int i = n+1; i<n2+1; i++) {
			if(!idx[i]) {
				count++;
			}
		}
		outSb.append(count).append("\n");
	}
}

/*
time = 168ms memorry = 14716KB
위의 로직의 설계순서는 아래와 같은 방식으로 진행 되었습니다.
1.입력을 받는다 0이 들어올때 까지 해당 값들을 모두 가지고 있어야함 입력의 
2.입력받은 값들중 최대값을 찾는다
3.에라토스 테네스의 체를 이용하여 입력값의 최대값의 2배 +1 크기 만큼의 배열을 처리한다
4.카운트를 세어 한번에 나중에 출력한다.

1번에서 입력값들을 쌓아두기 위해 StringBuilder를 이용하여 입력값들을 차래대로 0이 들어올때 까지 공백과 함께 append시켰습니다.
2.이후에 StringBuilder를 StirngTokenizer를 이용하여 token의 갯수만큼 int 배열을 선언하고 해당 배열에 값들을 차래대로 대입하면서 최대값을 찾아 size라는 변수에 저장하였습니다.
3.에레토스 테네스의 체를 이용하여 소수들을 처리하여 주는 메소드 eratos()를 호출하여 size*2+1 만큼의 배열을 처리하여 주었습니다.
4.이후에 입력받은 값들을 차래대로 process()메소드를 통해 카운트를 StirngBuilder에 쌓아 출력하였습니다.

*/
