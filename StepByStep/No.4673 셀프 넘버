/*
  
  셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.
  양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 
  예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.
  33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...
  n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 
  생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97
  10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.
  입력
  입력은 없다.

  출력
  10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.
  
*/


public class Main {
	public static void main(String[] args) {
		for(int i = 0; i<=10000; i++) {
			int count = 0;
			for(int j = 0; j<=i; j++) {
				if(j+(j/1000%10)+(j/100%10)+(j/10%10)+(j%10)==i) {
					count++;
					break;
				}
			}
			if(count==0) {
				System.out.println(i);
			}
		}
	}
}
/*
문제를 보고 함수의 구하는식을 구했다
문제에서는 d()라는 메소드를 사용했다. 단순하게 생각해서 메소드를 생성하지 않고 메인메소드 안에서 처리 하기만 반복했다.
단순한 방식으로 현제의 숫자 i를 이용하고 이 수보다 작은수 j를 점차 증가시키면 비교했다 작은수중 하나라도 해당 생성자가 발견되면 count를 증가 시키고 break를 이용해 for문을 빠져나왔다
이후에 count가 0 인수는 셀프 수
하지만 이런 방식은 상당히 직관 적이며 단순한 방식 이었다. 

다른 사람의 문제를 보고 깨달았다 boolean 형으로 10000개의 변수를 할당하고 1~10000까지의 수를 해당 함수 d에 대입하여 나온수에 true를 입력한후
전부 반복하여 보았다 이로서 flase의 값을 가지는 수는 셀프 넘버가 된다.

또한 조건식을 내가 푼 문제에서는 j+(j/1000%10)+(j/100%10)+(j/10%10)+(j%10) 으로 입력하여 필요가 없는 과정이 끼워져있다.
아래의 조건식은 
static int d(int n) {
		int sum = n;
		while(n!=0) {
			sum+=n%10;
			n/=10;
		}
		return sum;
	}
  
  아래와 같이 진행하게되면 1000의 자리수보다 작을 경우에는  3번 거치고나면 0이라는 값이 적용되어 해당 루프가 종료된다.
  따라서 아래의 식이 조금더 루프적으로 간단한거 같다.
*/

public class Main {

	public static void main(String[] args) {
		
		boolean[] check = new boolean[10000];
		
		for(int j=1;j<=10000;j++) {
			int n=d(j);
			if(n<=10000)
				check[n-1]=true;
		}
		
		StringBuilder buf = new StringBuilder();
		for(int i=0;i<10000;i++) {
			if(!check[i]) // 생성자가 없으면
				buf.append(i+1).append("\n");
		}
		System.out.println(buf.toString());
	}
	
	static int d(int n) {
		int sum = n;
		while(n!=0) {
			sum+=n%10;
			n/=10;
		}
		return sum;
	}
	
}

