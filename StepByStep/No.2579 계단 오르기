/*

    https://www.acmicpc.net/problem/2579

    계단 오르기 성공

    시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
    1 초	128 MB	115941	39700	28700	34.237%
    문제
    계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.



    <그림 1>

    예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.



    <그림 2>

    계단 오르는 데는 다음과 같은 규칙이 있다.

    계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
    연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
    마지막 도착 계단은 반드시 밟아야 한다.
    따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

    각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

    입력
    입력의 첫째 줄에 계단의 개수가 주어진다.

    둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.

    출력
    첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.

*/

/*
    풀이 :  점화식을 유도하는 과정이 지금까지 너무 어려웠는데
            지금까지의 유도방식은 -> 일단 한번 탐색을 마친후 값을 모두 출력해보고 해당값들에 대하여 수학적인 식을 유추하는 방법으로 풀었으니
            이번에 깨달은 방식은 N인상태가 있다고 할때 N인상태가 유도된 과정을 유추하고 해당 과정을 알고리즘으로 만들어 풀어냈습니다
            
            이번 문제의 점화식 유도 방식
            N은 N-1과 N-2에서 올라오는 방식 2가지가 존재하고
            제약 조건은 N => N+1 => N+2 는 불가능하다 즉 연속적인 수를 선택할 수 있는 겄은 2개가 까지이다
            따라서 dp테이블을 2차원 배열로 만들고 dp[N][2];의 크기를 가지는 테이블을 생성하면 된다
            dp[N][0]번에는 N-2에서 N으로 올라온 상태가 들어가고 N-2로 올 수 있는 경우는 이전에 올라온것이 1칸이든 2칸이든 상관없이 둘중 큰값을 넣으면 된다
            dp[N][1]번에는 N-1에서 N으로 올라온 상태가 들어가고 N-1로 올 수 있는 경우는 이전에 올라온것이 2칸인 경우 만 들어올 수 있다
            따라서 아래와 같은 점화식을 유추 할수 있었습니다.
            
            dp[idx][0] = stairs[idx] + Math.max(dp[idx-2][0], dp[idx-2][1]);
			      dp[idx][1] = stairs[idx] + dp[idx-1][0];
            
            
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main {
	
	static int N, count;
	static int[][] dp;
	static int[] stairs;
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
		stairs = new int[N];
		dp = new int[N][2];
		for(int i = 0; i < N; i++) {
			stairs[i] = Integer.parseInt(br.readLine());
		}
		
		
		//점화식 유도
		/*
		 * dp[N] 번째 계단에 가는 방법 = N-1 번째에서 가는법 N-2 번째에서 가는법 
		 * N-1 번째에서 왔을때 -> N-1 번이 2번연속이 아닐때
		 * N-1 번째를 3 번거친거를 방법 ? -> 
		 * 
		 * N-1[0] -> N-1 번째에서 오긴했으나 이전에 건너온 계단의 수가 2일때
		 * N-1[1] -> N-1이 1번이어진 상태
		 * N-1[2] -> N-1이 2번이어진 상태
		 * 
		 * 점화식 수정 ==================
		 * 
		 * N-2 -> N으로 올라온 것도 또한 1칸을 차지 한걸로 침
		 * 따라서 2칸1칸 올라오면 강제적으로 2칸을 가야함 !
     * 
     * 유도된 점화식 
     * dp[idx][0] = stairs[idx] + Math.max(dp[idx-2][0], dp[idx-2][1]);
		 * dp[idx][1] = stairs[idx] + dp[idx-1][0];
		 * 
		 */
		System.out.println(upStairs());
	}
	
	public static int upStairs() {
		//Bottom Up
		
		if(N==1) {
			return stairs[0];
		}
		
		//초기값 설정
		dp[0][0] = dp[0][1] = stairs[0];
		dp[1][0] = stairs[1];
		dp[1][1] = stairs[1] + dp[0][0];
		
		for(int idx = 2; idx < N; idx++) {
			dp[idx][0] = stairs[idx] + Math.max(dp[idx-2][0], dp[idx-2][1]);
			dp[idx][1] = stairs[idx] + dp[idx-1][0];
		}
		
		return Math.max(dp[N-1][0], dp[N-1][1]);
				
	}
}
